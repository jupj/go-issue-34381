// +build ignore

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type caseVisitor struct {
	cases []string
	w     io.Writer
}

func (c *caseVisitor) Visit(node ast.Node) ast.Visitor {
	switch n := node.(type) {
	case *ast.CaseClause:
		for _, expr := range n.List {
			if bl, ok := expr.(*ast.BasicLit); ok && bl.Kind == token.STRING {
				c.cases = append(c.cases, bl.Value)
			}
		}
		return &caseVisitor{w: c.w}

	case nil:
		if len(c.cases) > 0 {
			c.cases = deduplicate(c.cases)
			fmt.Fprintf(c.w, "\t{%s},\n", strings.Join(c.cases, ", "))
			c.cases = c.cases[:0]
		}
	}

	return c
}

func deduplicate(data []string) []string {
	sort.Strings(data)
	j := 0
	for i := 1; i < len(data); i++ {
		if data[j] == data[i] {
			// skip duplicate
			continue
		}

		j++
		data[j] = data[i]
	}
	return data[:j+1]
}

func main() {
	var output, src string
	output = "testcases.go"
	flag.StringVar(&src, "src", src, "Parse test data from source tree at `PATH`")
	flag.StringVar(&output, "out", output, "Generate test data to `FILE`")
	flag.Parse()

	if len(src) == 0 {
		log.Fatal("Please specify source tree")
	}

	var out io.Writer = os.Stdout
	if len(output) > 0 {
		f, err := os.Create(output)
		if err != nil {
			log.Fatal(err)
		}
		defer f.Close()
		out = f
	}

	fmt.Fprintf(out, `// Code generated by %s; DO NOT EDIT.
package main

var testcases = [][]string{
`, filepath.Base(os.Args[0]))

	err := filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			pkgs, _ := parser.ParseDir(token.NewFileSet(), path, nil, 0)
			for _, pkg := range pkgs {
				ast.Walk(&caseVisitor{w: out}, pkg)
			}
		}
		return nil
	})
	if err != nil {
		log.Fatal(err)
	}

	fmt.Fprintln(out, "}")
	return

}
